`nodejs`最大的亮点：事件机制和异步`IO`，对开发者并不透明
### 回调

* 异步编程的直接体现就是回调
* 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了
* js本身是单线程的，不可能在一段代码还未结束的时候去运行别的代码，因此不存在异步执行的概念
* 若某个函数是创建一个别的线程或者进程，并与js主线程并行的做一些事，并在事情结束后通知js主线程，就是另外的情况了

### 代码设计模式

异步编程有很多特有的代码设计模式，同样的功能使用同步方式和异步方式编写的代码差异会很大

#### 函数返回值

使用一个函数的输出作为另一个函数的输入，同步方式一般是

```
let output = fn1(fn2('input'));
// do another...
```

而异步方式下，由于函数执行结果不是通过返回值，二是通过回调函数传递，所以

```
fn2('input', output2 => {
    fn1(output2, output1 => {
        // do other...
    });
});
```

而异步这种方式回调嵌套回调，导致回调地狱，代码会成'>'形状。

#### 遍历数组

在遍历数组的时候，用某个函数依次对数据成员做一些处理也是常见需求，若是同步函数

```
let len = arr.length,
    i = 0;
for (; i < len; ++i) {
    arr[i] = sync(arr[i]);
}
// all arr items have processed.
```

如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。

```
(function next(i, len, cb) {
    if (i < len) {
        async(arr[i], value => {
            arr[i] = value;
            next(i + 1, len, cb);
        });
    } else {
        cb();
    }
}(0, arr.length, () => {
    // all arr items have processed.
}));
```

#### 异常处理

js自身提供的异常捕获和处理机制 `try ... catch ...`，只能用于同步执行的代码，可以通过setTimeout等方式来异步化...（暂时搁置）

### domain(域)

> [官方文档](http://nodejs.org/api/domain.html)

* 域，简单讲就是一个`js`运行环境。在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出
* 简化异步代码的异常处理
* `nodejs`通过`process`对象提供了捕获全局异常的方法